# Angular Architecture Rules

This document outlines the architectural rules and best practices for the Angular frontend application.

## 1. Project Structure

### Folder Organization
```
src/app/
├── core/              # Core functionality (services, guards, interceptors)
│   ├── guards/        # Route guards
│   ├── interceptors/   # HTTP interceptors
│   └── services/      # Core services (auth, API clients)
├── shared/            # Shared/reusable components
│   └── components/    # Reusable UI components
├── pages/             # Page-level components
├── layout/            # Layout components
└── components/        # Feature-specific components
```

### Naming Conventions
- **Components**: PascalCase with descriptive names (e.g., `AdminLoginComponent`)
- **Services**: PascalCase with "Service" suffix (e.g., `AuthService`)
- **Guards**: PascalCase with "Guard" suffix (e.g., `AuthGuard`)
- **Interceptors**: PascalCase with "Interceptor" suffix (e.g., `AuthInterceptor`)
- **Files**: kebab-case matching component name (e.g., `admin-login.component.ts`)

## 2. Component Architecture

### Standalone Components
- **All components must be standalone** (Angular 17+)
- Use `standalone: true` in component decorator
- Import only what you need in the component

### Component Structure
```typescript
@Component({
  selector: 'app-component-name',
  standalone: true,
  imports: [/* only necessary imports */],
  templateUrl: './component-name.component.html',
  styleUrl: './component-name.component.css'
})
export class ComponentNameComponent {
  // Component logic
}
```

### Component Responsibilities
- Components should be **thin** - delegate business logic to services
- Components handle presentation and user interaction
- Use `@Input()` and `@Output()` for parent-child communication
- Avoid direct API calls in components - use services

## 3. Styling with Tailwind CSS

### BEM Methodology
- Use **BEM (Block Element Modifier)** naming convention for CSS classes
- Pattern: `block__element--modifier`
- Example:
  ```html
  <div class="login">
    <div class="login__card">
      <h1 class="login__title">Title</h1>
      <button class="login__button login__button--primary">Click</button>
    </div>
  </div>
  ```

### Tailwind Configuration
- **Main Color**: Use `main-*` color scale for primary actions
  - Buttons: `bg-main-500`, `hover:bg-main-600`
  - Inputs: `border-main-500`, `focus:ring-main-100`
  - Links: `text-main-500`
- **Dynamic Colors**: Never use static hex colors - always use Tailwind color classes
- **Color Scale**: Use appropriate shade (50-950) for different contexts

### Reusable Components
- Create shared components in `shared/components/`
- Examples: `ButtonComponent`, `InputComponent`, `CardComponent`
- Components should accept props for customization
- Use Tailwind classes with BEM naming

## 4. Forms and Validation

### Reactive Forms
- **Always use Reactive Forms** (not Template-driven)
- Import `ReactiveFormsModule` in component
- Use `FormBuilder` for form creation
- Validate on both client and server side

### Validation Pattern
```typescript
this.form = this.fb.group({
  fieldName: ['', [Validators.required, Validators.minLength(3)]]
});
```

### Error Display
- Show validation errors inline with form fields
- Use BEM classes: `form__field-error`
- Display errors only after field is touched
- Provide clear, user-friendly error messages

## 5. Services and Dependency Injection

### Service Pattern
- Services are **singleton** by default (`providedIn: 'root'`)
- Use services for:
  - API calls
  - State management
  - Business logic
  - Data transformation

### API Client Usage
- **Never edit** `clientAPI.ts` - it's auto-generated by NSwag
- Create wrapper services (e.g., `AuthService`) that use generated clients
- Handle errors and transformations in wrapper services

### Service Example
```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  constructor(private adminClient: AdminClient) {}
  
  login(credentials: AdminLoginCommand): Observable<AdminLoginResponse> {
    return this.adminClient.login(credentials).pipe(
      tap(response => this.storeTokens(response))
    );
  }
}
```

## 6. HTTP Interceptors

### Authentication Interceptor
- Automatically add JWT token to all requests
- Read token from `AuthService`
- Add `Authorization: Bearer {token}` header
- Don't add token to login/register endpoints

### Interceptor Pattern
```typescript
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    if (token) {
      req = req.clone({
        setHeaders: { Authorization: `Bearer ${token}` }
      });
    }
    return next.handle(req);
  }
}
```

## 7. Routing and Guards

### Route Configuration
- Define routes in `app.routes.ts`
- Use lazy loading for feature modules (if not standalone)
- Protect routes with `AuthGuard`

### Route Structure
```typescript
export const routes: Routes = [
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: 'login', component: LoginComponent },
  {
    path: 'main',
    component: MainLayoutComponent,
    canActivate: [AuthGuard],
    children: [/* child routes */]
  }
];
```

### Auth Guard
- Check authentication state before allowing route access
- Redirect to login if not authenticated
- Use `AuthService.isAuthenticated()`

## 8. State Management

### Local Storage
- Store tokens in `localStorage` (not `sessionStorage`)
- Use consistent keys: `auth_token`, `refresh_token`, `user_data`
- Clear storage on logout

### Service State
- Use RxJS `BehaviorSubject` or `Subject` for reactive state
- Expose observables for components to subscribe
- Update state through service methods

## 9. Error Handling

### Error Display
- Show user-friendly error messages
- Use toast notifications for global errors
- Display inline errors for form validation
- Log errors to console in development

### Error Pattern
```typescript
this.service.method().subscribe({
  next: (data) => { /* handle success */ },
  error: (error) => {
    this.errorMessage = error?.result?.errorMessage || 'An error occurred';
  }
});
```

## 10. NSwag Integration

### Code Generation
- **NSwag** automatically generates TypeScript client services
- Generated file: `core/services/clientAPI.ts`
- **Never manually edit** this file - it's regenerated on build
- Configuration: `ECommerce.Server/nswag.json`

### Using Generated Services
- All clients are injectable: `AdminClient`, `CustomerClient`, `RoleClient`
- Services use `API_BASE_URL` injection token
- Configure base URL in `main.ts`:
  ```typescript
  {
    provide: API_BASE_URL,
    useValue: 'https://localhost:7020'
  }
  ```

### Wrapper Services
- Create wrapper services that use generated clients
- Handle token storage, error transformation, and business logic
- Keep components clean by using wrapper services

## 11. Best Practices

### Performance
- Use `OnPush` change detection strategy when possible
- Implement lazy loading for routes
- Use `trackBy` in `*ngFor` for large lists
- Avoid unnecessary subscriptions - use `async` pipe

### Accessibility
- Use semantic HTML elements
- Add ARIA labels where needed
- Ensure keyboard navigation works
- Test with screen readers

### Code Quality
- Follow Angular style guide
- Use TypeScript strict mode
- Write self-documenting code
- Keep components small and focused
- Extract reusable logic to services

### Testing
- Write unit tests for services
- Test components in isolation
- Mock dependencies
- Test user interactions

## 12. Tailwind CSS Guidelines

### Color Usage
- **Primary Actions**: Use `main-*` color scale
- **Errors**: Use `error-*` color scale
- **Success**: Use `success-*` color scale
- **Never use static colors** - always use Tailwind classes

### Responsive Design
- Use Tailwind responsive prefixes: `sm:`, `md:`, `lg:`, `xl:`
- Mobile-first approach
- Test on multiple screen sizes

### Utility Classes
- Prefer Tailwind utilities over custom CSS
- Use `@apply` directive in component CSS for repeated patterns
- Keep custom CSS minimal - use Tailwind classes in templates

### BEM + Tailwind
- Use BEM for class naming structure
- Use Tailwind for styling
- Example:
  ```html
  <div class="login__card bg-white rounded-xl shadow-lg p-6">
  ```

## 13. Component Communication

### Parent to Child
- Use `@Input()` properties
- Pass data through property binding

### Child to Parent
- Use `@Output()` with `EventEmitter`
- Emit events for parent to handle

### Sibling Components
- Use shared services with observables
- Or use state management solution

## 14. File Organization

### One Component Per File
- Each component in its own file
- File name matches component name (kebab-case)
- Co-locate template and styles with component

### Import Organization
```typescript
// 1. Angular core imports
import { Component, OnInit } from '@angular/core';

// 2. Angular feature imports
import { FormBuilder, FormGroup } from '@angular/forms';

// 3. Third-party imports
import { Observable } from 'rxjs';

// 4. Application imports
import { AuthService } from '../../core/services/auth.service';
```

